
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Script for searching pair of pulses which are not distinguishable by MIIPS.</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-09-11"><meta name="DC.source" content="miips_ambiguities_search.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Script for searching pair of pulses which are not distinguishable by MIIPS.</h1><!--introduction--><p>First we define a simple laser pulse, for ex. a linearly chirped Gaussian pulse. Then we obtain a second pulse by distorting the spectrum of the first one. The idea is to compare the MIIPS traces corrensponding to the two pulses. The traces look different because MIIPS is affected by the amplitude modulation. We then modify the phase of the first (gaussian) pulse until its MIIPS trace become equivalent to the MIIPS trace of the second distorted pulse. If we manage to do so we have found a pair of pulses with different amplitude and phase, which are not distinguishable by MIIPS.</p><p>2015 Alberto Comin - LMU Munich</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Define first pulse (simple Gaussian withe linear chirp)</a></li><li><a href="#2">Define a second pulse (the spectrally distorted one)</a></li><li><a href="#4">Define MIIPS parameters</a></li><li><a href="#5">Define reference MIIPS trace using the amplitude modulated pulse</a></li><li><a href="#6">Initialize parameters for ambiguities search</a></li><li><a href="#7">Seek equivalent trace by modifying the spectral phase of the first pulse</a></li><li><a href="#8">Plotting figures</a></li></ul></div><h2>Define first pulse (simple Gaussian withe linear chirp)<a name="1"></a></h2><pre class="codeinput">f0 = 0.4; <span class="comment">% central frequency (1/fs)</span>
fwhm = 10; <span class="comment">% FWHM of temporal intensity (fs)</span>
dt = 2; <span class="comment">% time step (fs)</span>
N = 2^10; <span class="comment">% number of domain points</span>
<span class="comment">% time domain array</span>
t = (-N/2:N/2-1).' * dt;
Et = exp(-2*log(2)*t.^2/fwhm^2);
<span class="comment">% laser pulse (requires LaserPulse class)</span>
p = LaserPulse(t,<span class="string">'fs'</span>,Et);
p.frequencyOffset = f0; <span class="comment">% set the central frequency</span>
p.normalize()
<span class="comment">% add some chirp</span>
p.polynomialPhase([200 0 0]) <span class="comment">% GDD = 100 fs^2</span>
</pre><h2>Define a second pulse (the spectrally distorted one)<a name="2"></a></h2><pre class="codeinput"><span class="comment">% create copy of first pulse</span>
pref = p.copy();

<span class="comment">% modulate amplitude (here are three example)</span>
pulsetype = 2;
<span class="keyword">switch</span> pulsetype <span class="comment">% can add new cases or modify these ones</span>
  <span class="keyword">case</span> 1
    pref.spectralAmplitude = pref.spectralAmplitude .* <span class="keyword">...</span>
      max(0, 1 - 0.8/pi*(pi/2+atan((p.frequencyArray-p.centralFrequency)*fwhm*10)));
  <span class="keyword">case</span> 2
    pref.spectralAmplitude = pref.spectralAmplitude .* <span class="keyword">...</span>
      max(0, 1 - 0.4*cos((p.frequencyArray-p.centralFrequency)*fwhm*10));
  <span class="keyword">case</span> 3
    pref.spectralAmplitude = pref.spectralAmplitude .* <span class="keyword">...</span>
      max(0, 1-0.8*exp(-(pref.frequencyArray-pref.centralFrequency).^2/pref.bandwidth.^2));
  <span class="keyword">case</span> 4
    pref.spectralAmplitude = pref.spectralAmplitude .* <span class="keyword">...</span>
      max(0, 1-0.8*exp(-(pref.frequencyArray-1.1*pref.centralFrequency).^2/pref.bandwidth.^2*4));
<span class="keyword">end</span>

pref.normalize()
</pre><p>We plot the two pulses. We will modify the spectral phase of the Gaussian one until its MIIPS traces will be equivalent to the MIIPS trace of the distorted pulse.</p><pre class="codeinput">figure(1)
set(gcf,<span class="string">'Name'</span>, <span class="string">'Initial Pulses'</span>);
p.plot(gcf);
pref.plot(gcf)
</pre><img vspace="5" hspace="5" src="miips_ambiguities_search_01.png" alt=""> <h2>Define MIIPS parameters<a name="4"></a></h2><pre class="codeinput">maxGDD = 500; <span class="comment">% must be bigger that the pulse chirp (fs^2)</span>
modFreq = 10; <span class="comment">% frequency of MIIPS modulation (fs)</span>
modAmp = maxGDD/modFreq^2; <span class="comment">% amplitude of MIIPS modulation (rad)</span>
phi = linspace(-4*pi, 4*pi, 4000); <span class="comment">% scanning phase (rad)</span>
fitrange = Inf; <span class="comment">% use the whose frequency range for MIIPS evaluation</span>
method = <span class="string">'peak-finding'</span>; <span class="comment">% 'peak-finding', 'centerOfMass' or 'weighted'</span>
</pre><h2>Define reference MIIPS trace using the amplitude modulated pulse<a name="5"></a></h2><pre class="codeinput"><span class="comment">% this is the MIIPS trace which we will try to match</span>
mref = Miips(pref, modAmp, modFreq, phi,<span class="keyword">...</span>
  <span class="string">'fitrange'</span>,fitrange,<span class="string">'analysisMethod'</span>,method);
</pre><h2>Initialize parameters for ambiguities search<a name="6"></a></h2><pre class="codeinput">nIter = 60; <span class="comment">% number of iterations of the algorithm</span>
maxCorr = maxGDD/2; <span class="comment">% maximum correction for the GDD error</span>
corrFact = 0.2; <span class="comment">% fraction of the correction to apply (smaller values give more stability)</span>
smoothingCorr = true; <span class="comment">% wether to smooth the correction before applying it</span>
smoothFact = .1;

<span class="comment">% this is the miips trace which will be modified until it matches 'mref'</span>
msim = Miips(p, modAmp, modFreq, phi,<span class="keyword">...</span>
  <span class="string">'fitrange'</span>, fitrange, <span class="string">'analysisMethod'</span>, method);

<span class="comment">% initialize GDD retrieved from msim</span>
retrGDD = zeros(numel(t), nIter);
retrGDD(:, 1) = msim.retrievedGDD;
<span class="comment">% initialize error array (difference betweeen GDDs retrieved from msim and mref)</span>
err = zeros(numel(t), nIter);
err(:, 1) = msim.retrievedGDD - mref.retrievedGDD;
</pre><h2>Seek equivalent trace by modifying the spectral phase of the first pulse<a name="7"></a></h2><pre class="codeinput">wb = waitbar(0, <span class="string">'matching reference trace...'</span>, <span class="keyword">...</span>
  <span class="string">'Name'</span>, <span class="string">'MIIPS Ambiguities Search'</span>, <span class="keyword">...</span>
  <span class="string">'CreateCancelBtn'</span>, <span class="string">'setappdata(gcbf,''canceling'',1)'</span>);
setappdata(wb, <span class="string">'canceling'</span>, 0);
<span class="keyword">for</span> n = 2:nIter
  <span class="comment">% calculate correction</span>
  corr = corrFact * err(:, n-1);
  <span class="keyword">if</span> smoothingCorr
    corr = smooth(corr,smoothFact,<span class="string">'lowess'</span>);
  <span class="keyword">end</span>
  corr = min(maxCorr, max(-maxCorr, corr));
  <span class="comment">% calcuate next guess for the GDD</span>
  retrGDD(:,n) = retrGDD(:,n-1) - corr;
  <span class="comment">% calculate the phase from the GDD</span>
  msim.inputPulse.spectralPhase = doubleIntegrateGDD(<span class="keyword">...</span>
    2*pi*mref.frequencyArray, 2*pi*mref.centralFrequency, retrGDD(:,n-1));
  <span class="comment">% update miips trace and calculate the new error</span>
  msim.update();
  err(:, n) = msim.retrievedGDD - mref.retrievedGDD;
  waitbar(n/nIter, wb, sprintf(<span class="string">'matching reference trace (%.f %%)'</span>, n/nIter*100))
  <span class="keyword">if</span> getappdata(wb, <span class="string">'canceling'</span>); <span class="keyword">break</span>; <span class="keyword">end</span>
<span class="keyword">end</span>
delete(wb)
</pre><h2>Plotting figures<a name="8"></a></h2><pre class="codeinput"><span class="comment">% Set the frequency range to be plotted:</span>
freqPlotRange = [-0.05, 0.05]+f0;
freqIndexRange = p.frequencyArray&gt;=freqPlotRange(1) &amp; p.frequencyArray&lt;=freqPlotRange(2);
</pre><p>First we plot the error of the GDD: it should converge to zero.</p><pre class="codeinput">figure(2)
set(gcf,<span class="string">'Name'</span>,<span class="string">'GDD error'</span>)
pcolor(5:size(err,2),pref.frequencyArray,(err(:,5:end))); shading <span class="string">flat</span>
caxis([0 max(max(err(freqIndexRange,:)))])
c = colorbar;
ylabel(c, <span class="string">'abs(err)'</span>)
ylim(freqPlotRange)
xlabel(<span class="string">'Iteration number'</span>)
ylabel(<span class="string">'frequency (1/fs)'</span>)
title(<span class="string">'GDD Error (abs. value)'</span>)
</pre><img vspace="5" hspace="5" src="miips_ambiguities_search_02.png" alt=""> <p>We compare the MIIPS traces and the GDD retrieved from them. If the retrieved GDDs are overlapped, than we found two pulses which are not distinguishable by MIIPS.</p><pre class="codeinput">figure(3)
subplot(3,1,1)
pcolor(mref)
ylim(freqPlotRange)
title(<span class="string">'Reference Trace'</span>)
subplot(3,1,2)
pcolor(msim)
ylim(freqPlotRange)
title(<span class="string">'Matching Trace'</span>)
subplot(3,1,3)
plot(mref.frequencyArray,[mref.retrievedGDD, msim.retrievedGDD]);
legend(<span class="string">'reference trace'</span>, <span class="string">'matching trace'</span>)
xlim(freqPlotRange)
ylim([min(mref.retrievedGDD(freqIndexRange)), max(mref.retrievedGDD(freqIndexRange))])
xlabel(<span class="string">'freq. (1/fs)'</span>)
ylabel(<span class="string">'GDD (fs^2)'</span>)
title(<span class="string">'Comparison Retrieved GDDs'</span>)
</pre><img vspace="5" hspace="5" src="miips_ambiguities_search_03.png" alt=""> <p>Now we plot the two 'indistinguishable' pulses.</p><pre class="codeinput">figure(4)
set(gcf,<span class="string">'Name'</span>,<span class="string">'Comparison pulses'</span>)
subplot(2,1,1)
h1 = plotyy(<span class="keyword">...</span>
  pref.frequencyArray,[pref.groupDelayDispersion, msim.inputPulse.groupDelayDispersion],<span class="keyword">...</span>
  p.frequencyArray,p.spectralIntensity);
legend(h1(1), <span class="string">'pref GDD'</span>,<span class="string">'p GDD'</span>,<span class="string">'p amp'</span>)
xlim(h1(1),freqPlotRange)
xlim(h1(2),freqPlotRange)
ylim([ <span class="keyword">...</span>
  min([pref.groupDelayDispersion(freqIndexRange); msim.inputPulse.groupDelayDispersion(freqIndexRange)]), <span class="keyword">...</span>
  max([pref.groupDelayDispersion(freqIndexRange); msim.inputPulse.groupDelayDispersion(freqIndexRange)]) ])
h1(1).YTick = linspace(round(h1(1).YLim(1),-1), round(h1(1).YLim(2),-1),6)';
xlabel(h1(1), <span class="string">'freq. (1/fs)'</span>)
ylabel(h1(1),<span class="string">'GDD (fs^2)'</span>)
ylabel(h1(2),<span class="string">'E(f)'</span>)
subplot(2,1,2)
h2 = plotyy(<span class="keyword">...</span>
  pref.frequencyArray,[pref.spectralPhase, msim.inputPulse.spectralPhase],<span class="keyword">...</span>
  p.frequencyArray,p.spectralIntensity);
legend(h2(1), <span class="string">'pref phase'</span>,<span class="string">'p phase'</span>,<span class="string">'p amp'</span>)
xlim(h2(1),freqPlotRange)
xlim(h2(2),freqPlotRange)
ylim([min(pref.spectralPhase(freqIndexRange)), max(pref.spectralPhase(freqIndexRange))])
h2(1).YTick = linspace(round(h2(1).YLim(1),-1), round(h2(1).YLim(2),-1),6)';
xlabel(h2(1), <span class="string">'freq. (1/fs)'</span>)
ylabel(h2(1),<span class="string">'phase (rad)'</span>)
ylabel(h2(2),<span class="string">'E(f)'</span>)
</pre><img vspace="5" hspace="5" src="miips_ambiguities_search_04.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Script for searching pair of pulses which are not distinguishable by MIIPS.
% First we define a simple laser pulse, for ex. a linearly chirped Gaussian
% pulse. Then we obtain a second pulse by distorting the spectrum of the
% first one. The idea is to compare the MIIPS traces corrensponding to the
% two pulses. The traces look different because MIIPS is affected by the
% amplitude modulation. We then modify the phase of the first (gaussian)
% pulse until its MIIPS trace become equivalent to the MIIPS trace of the
% second distorted pulse. If we manage to do so we have found a pair of
% pulses with different amplitude and phase, which are not distinguishable
% by MIIPS.
%
% 2015 Alberto Comin - LMU Munich

%% Define first pulse (simple Gaussian withe linear chirp)

f0 = 0.4; % central frequency (1/fs)
fwhm = 10; % FWHM of temporal intensity (fs)
dt = 2; % time step (fs)
N = 2^10; % number of domain points
% time domain array
t = (-N/2:N/2-1).' * dt;
Et = exp(-2*log(2)*t.^2/fwhm^2);
% laser pulse (requires LaserPulse class)
p = LaserPulse(t,'fs',Et);
p.frequencyOffset = f0; % set the central frequency
p.normalize()
% add some chirp
p.polynomialPhase([200 0 0]) % GDD = 100 fs^2


%% Define a second pulse (the spectrally distorted one)

% create copy of first pulse
pref = p.copy();

% modulate amplitude (here are three example)
pulsetype = 2;
switch pulsetype % can add new cases or modify these ones
  case 1
    pref.spectralAmplitude = pref.spectralAmplitude .* ...
      max(0, 1 - 0.8/pi*(pi/2+atan((p.frequencyArray-p.centralFrequency)*fwhm*10)));
  case 2
    pref.spectralAmplitude = pref.spectralAmplitude .* ...
      max(0, 1 - 0.4*cos((p.frequencyArray-p.centralFrequency)*fwhm*10));
  case 3
    pref.spectralAmplitude = pref.spectralAmplitude .* ...
      max(0, 1-0.8*exp(-(pref.frequencyArray-pref.centralFrequency).^2/pref.bandwidth.^2));
  case 4
    pref.spectralAmplitude = pref.spectralAmplitude .* ...
      max(0, 1-0.8*exp(-(pref.frequencyArray-1.1*pref.centralFrequency).^2/pref.bandwidth.^2*4));
end

pref.normalize()

%%
% We plot the two pulses. We will modify the spectral phase of the Gaussian
% one until its MIIPS traces will be equivalent to the MIIPS trace of the
% distorted pulse.

figure(1)
set(gcf,'Name', 'Initial Pulses');
p.plot(gcf);
pref.plot(gcf)

%% Define MIIPS parameters
maxGDD = 500; % must be bigger that the pulse chirp (fs^2)
modFreq = 10; % frequency of MIIPS modulation (fs)
modAmp = maxGDD/modFreq^2; % amplitude of MIIPS modulation (rad)
phi = linspace(-4*pi, 4*pi, 4000); % scanning phase (rad)
fitrange = Inf; % use the whose frequency range for MIIPS evaluation
method = 'peak-finding'; % 'peak-finding', 'centerOfMass' or 'weighted'

%% Define reference MIIPS trace using the amplitude modulated pulse

% this is the MIIPS trace which we will try to match
mref = Miips(pref, modAmp, modFreq, phi,...
  'fitrange',fitrange,'analysisMethod',method);


%% Initialize parameters for ambiguities search

nIter = 60; % number of iterations of the algorithm
maxCorr = maxGDD/2; % maximum correction for the GDD error
corrFact = 0.2; % fraction of the correction to apply (smaller values give more stability)
smoothingCorr = true; % wether to smooth the correction before applying it
smoothFact = .1;

% this is the miips trace which will be modified until it matches 'mref'
msim = Miips(p, modAmp, modFreq, phi,...
  'fitrange', fitrange, 'analysisMethod', method);

% initialize GDD retrieved from msim
retrGDD = zeros(numel(t), nIter); 
retrGDD(:, 1) = msim.retrievedGDD;
% initialize error array (difference betweeen GDDs retrieved from msim and mref)
err = zeros(numel(t), nIter);
err(:, 1) = msim.retrievedGDD - mref.retrievedGDD;

%% Seek equivalent trace by modifying the spectral phase of the first pulse
wb = waitbar(0, 'matching reference trace...', ...
  'Name', 'MIIPS Ambiguities Search', ...
  'CreateCancelBtn', 'setappdata(gcbf,''canceling'',1)');
setappdata(wb, 'canceling', 0);
for n = 2:nIter
  % calculate correction
  corr = corrFact * err(:, n-1);
  if smoothingCorr
    corr = smooth(corr,smoothFact,'lowess');
  end
  corr = min(maxCorr, max(-maxCorr, corr));
  % calcuate next guess for the GDD
  retrGDD(:,n) = retrGDD(:,n-1) - corr;
  % calculate the phase from the GDD
  msim.inputPulse.spectralPhase = doubleIntegrateGDD(...
    2*pi*mref.frequencyArray, 2*pi*mref.centralFrequency, retrGDD(:,n-1));
  % update miips trace and calculate the new error
  msim.update();
  err(:, n) = msim.retrievedGDD - mref.retrievedGDD;
  waitbar(n/nIter, wb, sprintf('matching reference trace (%.f %%)', n/nIter*100))
  if getappdata(wb, 'canceling'); break; end
end
delete(wb)

%% Plotting figures

% Set the frequency range to be plotted:
freqPlotRange = [-0.05, 0.05]+f0;
freqIndexRange = p.frequencyArray>=freqPlotRange(1) & p.frequencyArray<=freqPlotRange(2);
%%
% First we plot the error of the GDD: it should converge to zero.
figure(2)
set(gcf,'Name','GDD error')
pcolor(5:size(err,2),pref.frequencyArray,(err(:,5:end))); shading flat
caxis([0 max(max(err(freqIndexRange,:)))])
c = colorbar;
ylabel(c, 'abs(err)')
ylim(freqPlotRange)
xlabel('Iteration number')
ylabel('frequency (1/fs)')
title('GDD Error (abs. value)')

%%
% We compare the MIIPS traces and the GDD retrieved from them.
% If the retrieved GDDs are overlapped, than we found two pulses which are
% not distinguishable by MIIPS.
figure(3)
subplot(3,1,1)
pcolor(mref)
ylim(freqPlotRange)
title('Reference Trace')
subplot(3,1,2)
pcolor(msim)
ylim(freqPlotRange)
title('Matching Trace')
subplot(3,1,3)
plot(mref.frequencyArray,[mref.retrievedGDD, msim.retrievedGDD]);
legend('reference trace', 'matching trace')
xlim(freqPlotRange)
ylim([min(mref.retrievedGDD(freqIndexRange)), max(mref.retrievedGDD(freqIndexRange))])
xlabel('freq. (1/fs)')
ylabel('GDD (fs^2)')
title('Comparison Retrieved GDDs')

%%
% Now we plot the two 'indistinguishable' pulses.
figure(4)
set(gcf,'Name','Comparison pulses')
subplot(2,1,1)
h1 = plotyy(...
  pref.frequencyArray,[pref.groupDelayDispersion, msim.inputPulse.groupDelayDispersion],...
  p.frequencyArray,p.spectralIntensity);
legend(h1(1), 'pref GDD','p GDD','p amp')
xlim(h1(1),freqPlotRange)
xlim(h1(2),freqPlotRange)
ylim([ ...
  min([pref.groupDelayDispersion(freqIndexRange); msim.inputPulse.groupDelayDispersion(freqIndexRange)]), ...
  max([pref.groupDelayDispersion(freqIndexRange); msim.inputPulse.groupDelayDispersion(freqIndexRange)]) ])
h1(1).YTick = linspace(round(h1(1).YLim(1),-1), round(h1(1).YLim(2),-1),6)';
xlabel(h1(1), 'freq. (1/fs)')
ylabel(h1(1),'GDD (fs^2)')
ylabel(h1(2),'E(f)')
subplot(2,1,2)
h2 = plotyy(...
  pref.frequencyArray,[pref.spectralPhase, msim.inputPulse.spectralPhase],...
  p.frequencyArray,p.spectralIntensity);
legend(h2(1), 'pref phase','p phase','p amp')
xlim(h2(1),freqPlotRange)
xlim(h2(2),freqPlotRange)
ylim([min(pref.spectralPhase(freqIndexRange)), max(pref.spectralPhase(freqIndexRange))])
h2(1).YTick = linspace(round(h2(1).YLim(1),-1), round(h2(1).YLim(2),-1),6)';
xlabel(h2(1), 'freq. (1/fs)')
ylabel(h2(1),'phase (rad)')
ylabel(h2(2),'E(f)')
##### SOURCE END #####
--></body></html>